## 树
### 1. 二叉树
*满二叉树*:  
*完全二叉树*:  
*二叉查找数*:二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值.支持快速查找、插入、删除操作.  

#### 1.1 二叉树存储方式  
##### 1.1.1 基于数组的顺序存储法  
如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。  
##### 1.1.2 基于指针或引用的链式存储法 
每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。

``` go
type TreeNode struct {
	Val int
	Left *TreeNode
	Right *TreeNode
}
```
[总结]完全二叉树常用数组进行存储, 大部分二叉树使用链式存储法  

#### 1.2 二叉树遍历  
前, 中, 后序遍历  
##### 1.2.1 前序遍历
对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
##### 1.2.2 中序遍历
对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
##### 1.2.3 后序遍历
对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。  

实际上，二叉树的前、中、后序遍历就是一个递归的过程。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。所以，我们可以把前、中、后序遍历的递推公式都写出来。  

``` go
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
```  
``` go
type TreeNode struct {
	Val string
	Left *TreeNode
	Right *TreeNode
}

//前序
func PreOrder(root *TreeNode){
	//root->left->right
	if root == nil {
		return
	}
	fmt.Println("前序遍历 node", root.Val)
	PreOrder(root.Left)
	PreOrder(root.Right)
}
//中序
func InOrder(node *TreeNode){
	if node == nil {
		return
	}
	InOrder(node.Left)
	fmt.Println("中序遍历 node", node.Val)
	InOrder(node.Right)
}
//后序
func PostOrder (node *TreeNode){
	if node == nil {
		return
	}
	PostOrder(node.Left)
	PostOrder(node.Right)
	fmt.Println("后序遍历 node", node.Val)
}

//////////////////////////  main  ///////////////////////
func main() {
	nodeD := &TreeNode{Val:"D"}
	nodeE := &TreeNode{Val:"E"}
	nodeF := &TreeNode{Val:"F"}
	nodeG := &TreeNode{Val:"G"}

	nodeB := &TreeNode{Val:"B", Left:nodeD, Right:nodeE}
	nodeC := &TreeNode{Val:"C", Left:nodeF, Right:nodeG}

	nodeA := &TreeNode{Val:"A", Left:nodeB, Right:nodeC}
	PreOrder(nodeA)
	InOrder(nodeA)
	PostOrder(nodeA)
}
``` 
